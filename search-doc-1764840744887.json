{"searchDocs":[{"title":"Intro","type":0,"sectionRef":"#","url":"/Quaternion-RBLX/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is a Quaternion?​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#what-is-a-quaternion","content":" A quaternion is a mathematical object that can represent a rotation in 3D space using four numbers (x, y, z, w). Unlike Euler angles or CFrame.Angles, quaternions do not suffer from glimbal lock and can be smoothly interpolated.  Key points:  They represent rotation independently of position.They can be combined efficiently through multiplication.They allow for smooth interpolation between rotations (slerp).    ","version":"Next","tagName":"h2"},{"title":"How Quaternions Differ to CFrames?​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#how-quaternions-differ-to-cframes","content":" A CFrame is a 4x4 Affine Transformation Matrix. We however only think about CFrames as a 4x3 matrix, or a 3x3 rotation matrix and Vector3 position. This is because Roblox abstracted away the last row of the 4x4 matrix, which is always [0, 0, 0, 1]. Affine Transformation Matrices are industry standard for 3D engines, but most engines have you work with rotations using quaternions instead of on the matrix directly. The reason:  Stability: Repeated matrix multiplications can introduce numerical errors.Interpolation: Smooth rotation blending is easier with quaternions.Efficiency: Quaternions are easier to multiply than rotation matrices, and smaller in memory. Most game engines will store rotations as quaternions internally because of this, only converting to an affine transformation matrix for rendering or other areas where it performs better.  In Roblox, CFrame exposes this matrix directly, but working with quaternions allows you to benefit from these advantages while still converting to/from CFrames when needed.    ","version":"Next","tagName":"h3"},{"title":"Why Use Quaternions?​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#why-use-quaternions","content":" Even though Roblox provides many methods in CFrame for rotations, quaternions offer several important benefits:  ","version":"Next","tagName":"h2"},{"title":"1. Avoid Gimbal Lock​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#1-avoid-gimbal-lock","content":" Euler angles (Vector3) or incremental CFrame.Angles can suffer from gimbal lock, a situation where two rotation axes align and you lose a degree of freedom. Quaternions represent rotations in 4D space, eliminating gimbal lock entirely.  ","version":"Next","tagName":"h3"},{"title":"2. Smooth Interpolation​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#2-smooth-interpolation","content":" Rotations between two orientations can be smoothly interpolated using slerp (spherical linear interpolation), which is trivial with quaternions:  local q1 = Quaternion.fromCFrame(CFrame.Angles(0, 0, 0)) local q2 = Quaternion.fromCFrame(CFrame.Angles(0, math.rad(90), 0)) local qInterpolated = Quaternion.slerp(q1, q2, 0.5)   This produces a natural, consistent rotation, which is much harder to achieve with CFrames directly.  ","version":"Next","tagName":"h3"},{"title":"3. Compact and Efficient​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#3-compact-and-efficient","content":" Quaternions store rotations using only four numbers (x, y, z, w), instead of a full 3x3 matrix. They are easy to combine using multiplication, and more memory-efficient than repeatedly constructing CFrame matrices.  ","version":"Next","tagName":"h3"},{"title":"4. Stable Composition​","type":1,"pageTitle":"Intro","url":"/Quaternion-RBLX/docs/intro#4-stable-composition","content":" Combining multiple rotations is cleaner with quaternions:  local q1 = Quaternion.fromEulerAngles(0, math.rad(45), 0) local q2 = Quaternion.fromEulerAngles(math.rad(30), 0, 0) local qCombined = Quaternion.multiply(q1, q2) local cframe = Quaternion.rotation(qCombined)   With CFrames, repeated multiplication can introduce numerical drift, whereas quaternions remain stable and normalised.    Quaternions give you a robust, stable, and mathematically sound way to handle rotations in Roblox, making your animations, physics, and camera systems far more predictable and smooth than using CFrame angles alone. ","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/Quaternion-RBLX/docs/installation","content":"Installation WallyPesdeManual Get the latest version from wally.run/package/isoopod/quaternion-rblx Quaternion = &quot;isoopod/quaternion-rblx@x.x.x&quot; ","keywords":"","version":"Next"},{"title":"Advanced","type":0,"sectionRef":"#","url":"/Quaternion-RBLX/docs/advanced","content":"","keywords":"","version":"Next"},{"title":"API Overview (key features)​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#api-overview-key-features","content":" Quaternion-RBLX provides a comprehensive set of quaternion operations, including:  Constructors: .new(x, y, z, w), .fromEulerAngles(...), .fromAxisAngle(axis, angle), .fromCFrame(...), .lookAt(...), .lookAlong(...), .fromToRotation(...), etc.Decomposition: .getComponents(), .toEulerAngles(), .toAxisAngle(), .toCFrame(position), etc.Quaternion math: .multiply(...), .inverse(), .normalize(), .dot(...), .angle(...)Rotation of vectors: .rotateVector(...)Interpolation: .slerp(...), .nlerp(...), .rotateTowards(...), and in-place variants (e.g. .slerpInPlace(...), .rotateTowardsInPlace(...))Utility: .magnitude(), .magnitudeSquared(), .equals(), .fuzzyEquals(...), .tostring(...), property-style getters (.x, .y, .z, .w) etc.    ","version":"Next","tagName":"h2"},{"title":"Performance Considerations & “Pure” vs “In-Place / Mutating” Variants​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#performance-considerations--pure-vs-in-place--mutating-variants","content":" Because Quaternion-RBLX uses a fixed buffer type under the hood, it provides both pure (functional) and in-place (mutating) variants of many operations.  ","version":"Next","tagName":"h2"},{"title":"When to use pure (functional) methods​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#when-to-use-pure-functional-methods","content":" When you need immutability (keeping old orientations, branching rotations, preserving original quaternion state)When readability / clarity is more important than micro-optimisation — e.g. setup code, configuration, one-off rotations  Example:  local q1 = Quaternion.fromEulerAngles(0, math.rad(45), 0) local q2 = Quaternion.fromAxisAngle(Vector3.new(1,0,0), math.rad(30)) local qCombined = Quaternion.multiply(q1, q2)   Here both q1 and q2 remain unchanged; qCombined is new.  ","version":"Next","tagName":"h3"},{"title":"When to prefer in-place (mutating) methods​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#when-to-prefer-in-place-mutating-methods","content":" In performance-critical loops (e.g. per-frame updates, animations, physics loops)When you want to minimise memory allocations / garbage / buffer churnWhen you are reusing quaternion objects (e.g. continuously rotating an object, or interpolating over time)  Example:  local currentQ = Quaternion.fromCFrame(part.CFrame) -- reuse the same quaternion each frame Quaternion.slerpInPlace(currentQ, currentQ, targetQ, t) Quaternion.applyRotation(part, currentQ)   Or:  Quaternion.rotateTowardsInPlace(currentQ, currentQ, targetQ, math.rad(5) * dt) Quaternion.applyRotation(part, currentQ)   Because the buffer is mutated instead of creating a new quaternion each time, this reduces memory churn and can lead to smoother performance, especially in contexts where many quaternion operations happen per frame (e.g. real-time physics, animations, camera rigs, procedural systems).    ","version":"Next","tagName":"h3"},{"title":"Vector Rotations & Directional Transformations​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#vector-rotations--directional-transformations","content":" If you need to rotate direction vectors (like forward/up/right) or compute transformed offsets (e.g. firing direction, velocity vectors, local-space offsets), quaternions let you rotate vectors cleanly:  local q = Quaternion.fromAxisAngle(Vector3.new(0,1,0), math.rad(90)) local original = Vector3.new(1, 0, 0) local rotated = Quaternion.rotateVector(q, original) -- rotated is now roughly Vector3.new(0, 0, -1)   This is much cleaner than constructing a full CFrame just to rotate a vector, and avoids unnecessary overhead when you only care about direction — ideal for projectiles, physics impulses, local offsets, procedural motion, etc.    ","version":"Next","tagName":"h2"},{"title":"Rotation-Delta, Angular Velocity & Physics-Style Continuous Rotation​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#rotation-delta-angular-velocity--physics-style-continuous-rotation","content":" For continuous rotations — e.g. rotating an object at a constant angular velocity (wheels, spinning objects, rotating turrets), or applying incremental rotation deltas per frame — quaternions are excellent. You can convert an angular velocity (axis + angular speed) to a quaternion and multiply it with the current orientation each update:  local currentQ = Quaternion.fromCFrame(part.CFrame) local angularAxis = Vector3.new(0, 1, 0) local angularSpeed = math.rad(90) -- 90 degrees per second game:GetService(&quot;RunService&quot;).Heartbeat:Connect(function(dt) local deltaQ = Quaternion.fromAxisAngle(angularAxis, angularSpeed * dt) Quaternion.multiplyInPlace(currentQ, deltaQ, currentQ) Quaternion.applyRotation(part, currentQ) end)   This maintains smooth, stable rotation over time without accumulating drift, and works cleanly even with changing frame rates.    ","version":"Next","tagName":"h2"},{"title":"Advanced Example​","type":1,"pageTitle":"Advanced","url":"/Quaternion-RBLX/docs/advanced#advanced-example","content":" local part = workspace.Turret local currentQ = Quaternion.fromCFrame(part.CFrame) local targetPos = workspace.Target.Position local rotationSpeed = math.rad(30) -- spin speed (radians per second) game:GetService(&quot;RunService&quot;).Heartbeat:Connect(function(dt) -- 1. Compute look-at quaternion local lookQ = Quaternion.lookAt(part.Position, targetPos) -- 2. Rotate current orientation toward lookQ (limited angular speed) Quaternion.rotateTowardsInPlace(currentQ, currentQ, lookQ, rotationSpeed * dt) -- 3. Apply a slow continuous spin around Z (e.g. turret barrel) local spinQ = Quaternion.fromAxisAngle(Vector3.ZAxis, rotationSpeed * dt) Quaternion.multiplyInPlace(currentQ, spinQ, currentQ) Quaternion.applyRotation(part, currentQ) end)   This snippet shows how you can mix interpolation, look-at orientation, and continuous rotation — all cleanly handled via quaternions, with minimal allocations if used with in-place / reused quaternion buffers. ","version":"Next","tagName":"h2"},{"title":"Quickstart","type":0,"sectionRef":"#","url":"/Quaternion-RBLX/docs/usage","content":"","keywords":"","version":"Next"},{"title":"Basic Usage​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#basic-usage","content":" local Quaternion = require(path.to.Quaternion) -- Create a quaternion rotation from a CFrame local cframeRotation = Quaternion.fromCFrame(workspace.CurrentCamera.CFrame) -- Create a quaternion rotation from Euler Angles local eulerRotation = Quaternion.fromEulerAngles(0, math.rad(45), 0) -- Combine the rotations local combinedRotation = Quaternion.multiply(eulerRotation, cframeRotation) -- Set the camera to the new rotation Quaternion.applyRotation(workspace.CurrentCamera, combinedRotation)   This short example shows you can use Quaternions to rotate the camera by 45 degrees on the yaw axis.  It should be noted here that quaternion multiplication is not commutative; the order of multiplication matters.  When you multiply two quaternions, you are applying one rotation after another. The right-hand side quaternion (rhs) is applied first, and the left-hand side quaternion (lhs) is applied after that. In other words, lhs * rhs is taking rhs and rotating it by lhs.  This is the same as CFrameA * CFrameB; B is applied first and then transformed by A.    ","version":"Next","tagName":"h2"},{"title":"Common Quaternion Functions​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#common-quaternion-functions","content":" Operation\tMethod / UseFrom Euler angles\tQuaternion.fromEulerAngles(x, y, z) From axis + angle\tQuaternion.fromAxisAngle(axisVec, angleRadians) From a CFrame\tQuaternion.fromCFrame(someCFrame) Multiply / combine rotations\tQuaternion.multiply(q1, q2) Interpolate between orientations\tQuaternion.slerp(q1, q2, t) - useful for smooth transitions Convert quaternion → CFrame\tQuaternion.toCFrame(x, y, z, q) or Quaternion.toCFrameAtPosition(posVec, q) Apply a rotation to a part\tQuaternion.applyRotation(partOrModel, q) Invert quaternion\tQuaternion.inverse(q) Get the identity quaternion\tQuaternion.identity() Get the angle between quaternions\tQuaternion.angle(q1, q2) Look at / look along vectors\tQuaternion.lookAt(pos1, pos2) or Quaternion.lookAlong(forward, up) Quaternion between two directions\tQuaternion.fromToRotation(dir1, dir2)    ","version":"Next","tagName":"h2"},{"title":"When to use​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#when-to-use","content":" ","version":"Next","tagName":"h2"},{"title":"Smooth Interpolation & Animation Transitions​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#smooth-interpolation--animation-transitions","content":" If you want to interpolate between two orientations (e.g. camera turning, character aiming, UI rotations), using quaternions + slerp gives smooth, stable transitions. Doing the same via repeated CFrame.Angles or direct matrix‑blending often looks janky or results in interpolation artifacts.  ","version":"Next","tagName":"h3"},{"title":"Clean Composition of Multiple Rotations​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#clean-composition-of-multiple-rotations","content":" For complex rotations — like rotating an object around multiple axes over time, or applying sequential rotations relative to different frames — quaternions let you compose rotations reliably by quaternion multiplication. This avoids issues that arise when chaining CFrame multiplications and manual angle bookkeeping.  ","version":"Next","tagName":"h3"},{"title":"Avoiding Numerical Instability & Gimbal‑Lock Issues​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#avoiding-numerical-instability--gimballock-issues","content":" When using Euler angles (or incremental angle updates), you risk gimbal lock or edge‑case singularities depending on axis‑order. Quaternions sidestep this entirely. Also, quaternion mathematics tends to remain more numerically stable when combining many rotations.  ","version":"Next","tagName":"h3"},{"title":"Efficiency & Clean Code for Rotation‑Heavy Systems​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#efficiency--clean-code-for-rotationheavy-systems","content":" For any system where rotation is a first‑class concern (camera rigs, physics‑based movement, orientation tweening, spaceship attitude control, procedural motion, etc.), using a quaternion library simplifies code and reduces complexity: rotations become composable, invertible, and easy to manipulate.  ","version":"Next","tagName":"h3"},{"title":"Interoperability with Roblox’s CFrame System​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#interoperability-with-robloxs-cframe-system","content":" Because Quaternion‑RBLX lets you create a quaternion from a CFrame and convert back with :ToCFrame(), you can use it as a drop‑in enhancement in existing codebases — mixing quaternion logic where needed, and falling back to CFrame where convenient.    Use plain CFrame when you only need simple transforms: positioning, or static orientation, or when you compose transforms in a trivial way and don’t need interpolation or complex rotations.    ","version":"Next","tagName":"h3"},{"title":"Example Use Cases​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#example-use-cases","content":" -- Example: Smoothly rotating a part toward a target orientation local startQ = Quaternion.fromCFrame(part.CFrame) local targetQ = Quaternion.fromEulerAngles(0, math.rad(180), 0) -- face backwards local t = 0 game:GetService(&quot;RunService&quot;).Heartbeat:Connect(function(dt) t = math.min(t + dt, 1) local qInterp = Quaternion.slerp(startQ, targetQ, t) Quaternion.applyRotation(part, qInterp) end)   -- Example: Combining rotations - e.g. yaw then pitch local yaw = Quaternion.fromAxisAngle(Vector3.new(0, 1, 0), math.rad(45)) local pitch = Quaternion.fromAxisAngle(Vector3.new(1, 0, 0), math.rad(30)) local final = Quaternion.multiply(yaw, pitch) Quaternion.applyRotation(part, final)   -- Example: Look‑direction orientation (e.g. camera / turret / head) Quaternion.applyRotation(part, Quaternion.lookAt(part.Position, targetPosition))     ","version":"Next","tagName":"h2"},{"title":"Summary​","type":1,"pageTitle":"Quickstart","url":"/Quaternion-RBLX/docs/usage#summary","content":" Quaternion‑RBLX gives you a robust, expressive, and stable way to handle rotations. It plays nicely with Roblox’s native CFrame system, yet unlocks more advanced rotation‑centric logic: smooth interpolation, complex composition, orientation blending, look‑at logic, and more.  If your game or simulation involves anything more than “set this part to a fixed rotation” — especially dynamic or continuous rotations — quaternions are absolutely worth using. ","version":"Next","tagName":"h2"},{"title":"Quaternion","type":0,"sectionRef":"#","url":"/Quaternion-RBLX/api/Quaternion","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#types","content":" ","version":null,"tagName":"h2"},{"title":"Quaternion​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#Quaternion","content":"&lt;/&gt; type Quaternion = buffer A branded buffer type representing a quaternion, 16 bytes. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#functions","content":" ","version":null,"tagName":"h2"},{"title":"z​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#z","content":"Property &lt;/&gt; Quaternion.z( q: Quaternion-- The quaternion. ) → number-- The z component (k). Gets the z component of the quaternion.  ","version":null,"tagName":"h3"},{"title":"fuzzyEquals​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#fuzzyEquals","content":"Method &lt;/&gt; Quaternion.fuzzyEquals( q1: Quaternion, q2: Quaternion, epsilon: number-- Allowed rotational error. ) → boolean Checks approximate rotational equality within epsilon using the quaternion dot product.  ","version":null,"tagName":"h3"},{"title":"setFromToRotation​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#setFromToRotation","content":"Method Mutating &lt;/&gt; Quaternion.setFromToRotation( q: Quaternion,-- The quaternion to set. from: Vector3 ,-- The starting direction vector. to: Vector3 -- The target direction vector. ) → Quaternion-- q Sets an existing quaternion so that it represents the rotation from one direction vector to another.  ","version":null,"tagName":"h3"},{"title":"w​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#w","content":"Property &lt;/&gt; Quaternion.w( q: Quaternion-- The quaternion. ) → number-- The w component (real part). Gets the w component of the quaternion.  ","version":null,"tagName":"h3"},{"title":"lookVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#lookVector","content":"Property &lt;/&gt; Quaternion.lookVector( q: Quaternion-- The quaternion. ) → Vector3 -- The look direction vector of the quaternion. Gets the look direction vector of the quaternion (opposite to zVector).  ","version":null,"tagName":"h3"},{"title":"normalize​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#normalize","content":"Method Pure &lt;/&gt; Quaternion.normalize( q: Quaternion-- The quaternion. ) → Quaternion-- The normalized quaternion. Returns a normalized version of the quaternion.  ","version":null,"tagName":"h3"},{"title":"setAxisAngle​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#setAxisAngle","content":"Method Mutating &lt;/&gt; Quaternion.setAxisAngle( q: Quaternion,-- The quaternion to set. axis: Vector3 ,-- The axis of rotation. angle: number-- The angle of rotation in radians. ) → () Sets an existing quaternion from an axis-angle representation.  ","version":null,"tagName":"h3"},{"title":"inverseInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#inverseInPlace","content":"Method Mutating &lt;/&gt; Quaternion.inverseInPlace( q: Quaternion-- The quaternion to invert. ) → Quaternion-- q Inverts the quaternion in place.  ","version":null,"tagName":"h3"},{"title":"setLookRotation​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#setLookRotation","content":"Method Mutating &lt;/&gt; Quaternion.setLookRotation( q: Quaternion,-- The quaternion to set. forward: Vector3 ,-- The forward direction vector. up: Vector3 -- The up direction vector. ) → Quaternion-- q Sets an existing quaternion so that it represents a rotation looking in a specified forward direction with a given up direction.  ","version":null,"tagName":"h3"},{"title":"upVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#upVector","content":"Property &lt;/&gt; Quaternion.upVector( q: Quaternion-- The quaternion. ) → Vector3 -- The up direction vector of the quaternion. Gets the up direction vector of the quaternion (equivalent to Quaternion.yVector).  ","version":null,"tagName":"h3"},{"title":"magnitude​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#magnitude","content":"Property &lt;/&gt; Quaternion.magnitude( q: Quaternion-- The quaternion. ) → number-- The magnitude of the quaternion. Gets the magnitude (length) of the quaternion.  ","version":null,"tagName":"h3"},{"title":"rotateTowardsInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#rotateTowardsInPlace","content":"Method Mutating &lt;/&gt; Quaternion.rotateTowardsInPlace( out: Quaternion,-- The quaternion to store the result. from: Quaternion,-- The starting quaternion. to: Quaternion,-- The target quaternion. maxRadiansDelta: number-- The maximum angle in radians to rotate. ) → Quaternion-- out Rotates one quaternion towards another by a maximum angle in radians, storing the result in out. out can be the same quaternion as from or to.  ","version":null,"tagName":"h3"},{"title":"nlerp​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#nlerp","content":"Method Pure &lt;/&gt; Quaternion.nlerp( from: Quaternion,-- The starting quaternion. to: Quaternion,-- The target quaternion. t: number-- The interpolation factor (0 to 1). ) → Quaternion-- The interpolated quaternion. Linearly interpolates between two quaternions and normalizes the result.  ","version":null,"tagName":"h3"},{"title":"toCFrameFromPosition​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#toCFrameFromPosition","content":"Decomposition &lt;/&gt; Quaternion.toCFrameFromPosition( position: Vector3 ,-- The position vector. q: Quaternion-- The quaternion. ) → CFrame -- The resulting CFrame. Converts the quaternion and position vector to a CFrame. You can use Quaternion.rotation if position is not needed.  ","version":null,"tagName":"h3"},{"title":"identity​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#identity","content":"Constructor &lt;/&gt; Quaternion.identity() → Quaternion-- The identity quaternion (0, 0, 0, 1). Creates and returns the identity quaternion.  ","version":null,"tagName":"h3"},{"title":"inverseUnitInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#inverseUnitInPlace","content":"Method Mutating &lt;/&gt; Quaternion.inverseUnitInPlace( q: Quaternion-- The unit quaternion to invert. ) → Quaternion-- q Inverts a unit quaternion in place. This is more efficient than quaternion.inverseInPlace since it assumes the quaternion is normalized. For a unit quaternion, the inverse is simply the conjugate. For non-unit quaternions, this will return the conjugate, not the inverse.  ","version":null,"tagName":"h3"},{"title":"rotateVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#rotateVector","content":"Method &lt;/&gt; Quaternion.rotateVector( q: Quaternion,-- The quaternion. v: Vector3 -- The vector to rotate. ) → Vector3 -- The rotated vector. Rotates a vector by the quaternion.  ","version":null,"tagName":"h3"},{"title":"toEulerAngles​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#toEulerAngles","content":"Decomposition &lt;/&gt; Quaternion.toEulerAngles( q: Quaternion-- The quaternion. ) → number,number,number-- The Euler angles (pitch, yaw, roll) in radians. Converts the quaternion to Euler angles (XYZ order) in radians.  ","version":null,"tagName":"h3"},{"title":"inverse​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#inverse","content":"Method Pure &lt;/&gt; Quaternion.inverse( q: Quaternion-- The quaternion. ) → Quaternion-- The inverse of the quaternion. Returns the inverse of the quaternion.  ","version":null,"tagName":"h3"},{"title":"dot​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#dot","content":"Method &lt;/&gt; Quaternion.dot( q1: Quaternion,-- The first quaternion. q2: Quaternion-- The second quaternion. ) → number-- The dot product of the two quaternions. Calculates the dot product of two quaternions.  ","version":null,"tagName":"h3"},{"title":"rightVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#rightVector","content":"Property &lt;/&gt; Quaternion.rightVector( q: Quaternion-- The quaternion. ) → Vector3 -- The right direction vector of the quaternion. Gets the right direction vector of the quaternion (equivalent to Quaternion.xVector).  ","version":null,"tagName":"h3"},{"title":"slerpFromIdentityInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#slerpFromIdentityInPlace","content":"Method Mutating &lt;/&gt; Quaternion.slerpFromIdentityInPlace( out: Quaternion,-- The quaternion to store the result. to: Quaternion,-- The target quaternion. t: number-- The interpolation factor (0 to 1). ) → Quaternion-- out Optimized SLERP from identity quaternion to to. Stores the result in out. out can be the same quaternion as to.  ","version":null,"tagName":"h3"},{"title":"y​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#y","content":"Property &lt;/&gt; Quaternion.y( q: Quaternion-- The quaternion. ) → number-- The y component (j). Gets the y component of the quaternion.  ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#new","content":"Constructor &lt;/&gt; Quaternion.new( x: number,-- The x component (i). y: number,-- The y component (j). z: number,-- The z component (k). w: number-- The w component (real part). ) → Quaternion-- The quaternion data structure. Creates a new Quaternion.  ","version":null,"tagName":"h3"},{"title":"slerpFromIdentity​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#slerpFromIdentity","content":"Method Pure &lt;/&gt; Quaternion.slerpFromIdentity( to: Quaternion,-- The target quaternion. t: number-- The interpolation factor (0 to 1). ) → Quaternion-- The spherically interpolated quaternion from identity. Optimized SLERP from identity quaternion to to.  ","version":null,"tagName":"h3"},{"title":"multiply​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#multiply","content":"Method Pure &lt;/&gt; Quaternion.multiply( lhs: Quaternion,-- The left-hand side quaternion. rhs: Quaternion-- The right-hand side quaternion. ) → Quaternion-- The resulting quaternion from the multiplication. Multiplies the left-hand side quaternion by the right-hand side quaternion. NOTE Quaternion multiplication is not commutative; the order of multiplication matters. When you multiply two quaternions, you are applying one rotation after another. The right-hand side quaternion (rhs) is applied first, and the left-hand side quaternion (lhs) is applied after that. In other words, lhs * rhs is taking rhs and rotating it by lhs. This is the same as CFrameA * CFrameB; B is applied first and then transformed by A.  ","version":null,"tagName":"h3"},{"title":"fromToRotation​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#fromToRotation","content":"Constructor &lt;/&gt; Quaternion.fromToRotation( from: Vector3 ,-- The starting direction vector. to: Vector3 -- The target direction vector. ) → Quaternion-- The resulting quaternion representing the rotation from from to to. Creates a quaternion that represents the rotation from one direction vector to another.  ","version":null,"tagName":"h3"},{"title":"yVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#yVector","content":"Property &lt;/&gt; Quaternion.yVector( q: Quaternion-- The quaternion. ) → Vector3 -- The up direction vector of the quaternion. Gets the up direction vector of the quaternion.  ","version":null,"tagName":"h3"},{"title":"xVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#xVector","content":"Property &lt;/&gt; Quaternion.xVector( q: Quaternion-- The quaternion. ) → Vector3 -- The right direction vector of the quaternion. Gets the right direction vector of the quaternion.  ","version":null,"tagName":"h3"},{"title":"zVector​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#zVector","content":"Property &lt;/&gt; Quaternion.zVector( q: Quaternion-- The quaternion. ) → Vector3 -- The forward direction vector of the quaternion. Gets the forward direction vector of the quaternion (opposite to lookVector).  ","version":null,"tagName":"h3"},{"title":"applyRotation​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#applyRotation","content":"Method &lt;/&gt; Quaternion.applyRotation( target: PVInstance ,-- A part or model to set the rotation of q: Quaternion-- The quaternion. ) → () Applies the quaternion's rotation to the target without touching its position.  ","version":null,"tagName":"h3"},{"title":"lookAlong​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#lookAlong","content":"Constructor &lt;/&gt; Quaternion.lookAlong( forward: Vector3 ,-- The forward direction vector. up: Vector3 -- The up direction vector. ) → Quaternion-- The resulting quaternion representing the rotation. Creates a quaternion that represents a rotation looking in a specified forward direction with a given up direction.  ","version":null,"tagName":"h3"},{"title":"nlerpInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#nlerpInPlace","content":"Method Mutating &lt;/&gt; Quaternion.nlerpInPlace( out: Quaternion,-- The quaternion to store the result. from: Quaternion,-- The starting quaternion. to: Quaternion,-- The target quaternion. t: number-- The interpolation factor (0 to 1). ) → Quaternion-- out Linearly interpolates between two quaternions and normalizes the result, storing it in out. out can be the same quaternion as from or to.  ","version":null,"tagName":"h3"},{"title":"toCFrame​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#toCFrame","content":"Decomposition &lt;/&gt; Quaternion.toCFrame( x: number,-- The x position. y: number,-- The y position. z: number,-- The z position. q: Quaternion-- The quaternion. ) → CFrame -- The resulting CFrame. Converts the quaternion and position to a CFrame. You can use Quaternion.rotation if position is not needed.  ","version":null,"tagName":"h3"},{"title":"equals​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#equals","content":"Method &lt;/&gt; Quaternion.equals( q1: Quaternion,-- The first quaternion. q2: Quaternion-- The second quaternion. ) → boolean-- Whether the two quaternions are equal. Compares two quaternions for equality.  ","version":null,"tagName":"h3"},{"title":"x​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#x","content":"Property &lt;/&gt; Quaternion.x( q: Quaternion-- The quaternion. ) → number-- The x component (i). Gets the x component of the quaternion.  ","version":null,"tagName":"h3"},{"title":"tostring​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#tostring","content":"Decomposition &lt;/&gt; Quaternion.tostring( q: Quaternion,-- The quaternion. format: string?-- Optional format string for each component. ) → string-- The string representation of the quaternion. Converts the quaternion to a string representation. Quaternion does not have a metatable to support the __tostring metamethod, so this function must be used explicitly.  ","version":null,"tagName":"h3"},{"title":"magnitudeSquared​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#magnitudeSquared","content":"Property &lt;/&gt; Quaternion.magnitudeSquared( q: Quaternion-- The quaternion. ) → number-- The squared magnitude of the quaternion. Gets the squared magnitude of the quaternion.  ","version":null,"tagName":"h3"},{"title":"set​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#set","content":"Method Mutating &lt;/&gt; Quaternion.set( q: Quaternion,-- The quaternion. x: number,-- The x component (i). y: number,-- The y component (j). z: number,-- The z component (k). w: number-- The w component (real part). ) → Quaternion-- q Sets the components of the quaternion.  ","version":null,"tagName":"h3"},{"title":"fromAxisAngle​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#fromAxisAngle","content":"Constructor &lt;/&gt; Quaternion.fromAxisAngle( axis: Vector3 ,-- The axis of rotation. angle: number-- The angle in radians. ) → Quaternion-- The resulting quaternion. Creates a quaternion from an axis-angle representation.  ","version":null,"tagName":"h3"},{"title":"slerpInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#slerpInPlace","content":"Method Mutating &lt;/&gt; Quaternion.slerpInPlace( out: Quaternion,-- The quaternion to store the result. from: Quaternion,-- The starting quaternion. to: Quaternion,-- The target quaternion. t: number-- The interpolation factor (0 to 1). ) → Quaternion-- out Spherically interpolates between two quaternions and stores the result in out. out can be the same quaternion as from or to.  ","version":null,"tagName":"h3"},{"title":"lookAt​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#lookAt","content":"Constructor &lt;/&gt; Quaternion.lookAt( from: Vector3 ,-- The starting position. to: Vector3 ,-- The target position to look at. up: Vector3? -- Optional up direction vector. Defaults to (0, 1, 0) if not provided. ) → Quaternion-- The resulting quaternion representing the rotation to look at the target. Creates a quaternion that represents a rotation looking from one position to another, with an optional up direction.  ","version":null,"tagName":"h3"},{"title":"toAxisAngle​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#toAxisAngle","content":"Decomposition &lt;/&gt; Quaternion.toAxisAngle( q: Quaternion-- The quaternion. ) → Vector3, number-- The axis of rotation as a Vector3 and the angle in radians. Converts the quaternion to an axis-angle representation.  ","version":null,"tagName":"h3"},{"title":"inverseUnit​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#inverseUnit","content":"Method Pure &lt;/&gt; Quaternion.inverseUnit( q: Quaternion-- The unit quaternion. ) → Quaternion-- The inverse of the unit quaternion. Returns the inverse of a unit quaternion. This is more efficient than quaternion.inverse since it assumes the quaternion is normalized. For a unit quaternion, the inverse is simply the conjugate. For non-unit quaternions, this will return the conjugate, not the inverse.  ","version":null,"tagName":"h3"},{"title":"fromCFrame​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#fromCFrame","content":"Constructor &lt;/&gt; Quaternion.fromCFrame( cf: CFrame -- The CFrame to convert. ) → Quaternion-- The resulting quaternion. Creates a quaternion from a CFrame's rotation.  ","version":null,"tagName":"h3"},{"title":"normalizeInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#normalizeInPlace","content":"Method Mutating &lt;/&gt; Quaternion.normalizeInPlace( q: Quaternion-- The quaternion to normalize. ) → Quaternion-- q Normalizes the quaternion in place.  ","version":null,"tagName":"h3"},{"title":"setEulerAngles​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#setEulerAngles","content":"Method Mutating &lt;/&gt; Quaternion.setEulerAngles( q: Quaternion,-- The quaternion to set. x: number,-- The rotation around the x-axis in radians (pitch). y: number,-- The rotation around the y-axis in radians (yaw). z: number-- The rotation around the z-axis in radians (roll). ) → Quaternion-- q Sets an existing quaternion from Euler angles XYZ in radians.  ","version":null,"tagName":"h3"},{"title":"getComponents​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#getComponents","content":"Decomposition &lt;/&gt; Quaternion.getComponents( q: Quaternion-- The quaternion. ) → number,number,number,number-- The components (x, y, z, w). Gets all components of the quaternion.  ","version":null,"tagName":"h3"},{"title":"multiplyInPlace​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#multiplyInPlace","content":"Method Mutating &lt;/&gt; Quaternion.multiplyInPlace( out: Quaternion,-- The quaternion to store the result. lhs: Quaternion,-- The left-hand side quaternion. rhs: Quaternion-- The right-hand side quaternion. ) → Quaternion-- out Multiplies the left-hand side quaternion by the right-hand side quaternion in place, storing the result in out. out can be the same quaternion as lhs or rhs. NOTE Quaternion multiplication is not commutative; the order of multiplication matters. When you multiply two quaternions, you are applying one rotation after another. The right-hand side quaternion (rhs) is applied first, and the left-hand side quaternion (lhs) is applied after that. In other words, lhs * rhs is taking rhs and rotating it by lhs. This is the same as CFrameA * CFrameB; B is applied first and then transformed by A.  ","version":null,"tagName":"h3"},{"title":"angle​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#angle","content":"Method &lt;/&gt; Quaternion.angle( q1: Quaternion,-- The first quaternion. q2: Quaternion-- The second quaternion. ) → number-- The angle in radians between the two quaternions. Calculates the angle in radians between two quaternions.  ","version":null,"tagName":"h3"},{"title":"slerp​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#slerp","content":"Method Pure &lt;/&gt; Quaternion.slerp( from: Quaternion,-- The starting quaternion. to: Quaternion,-- The target quaternion. t: number-- The interpolation factor (0 to 1). ) → Quaternion-- The spherically interpolated quaternion. Spherically interpolates between two quaternions.  ","version":null,"tagName":"h3"},{"title":"rotation​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#rotation","content":"Property &lt;/&gt; Quaternion.rotation( q: Quaternion-- The quaternion. ) → CFrame -- The CFrame representing the rotation of the quaternion. Converts the quaternion to a CFrame representing its rotation.  ","version":null,"tagName":"h3"},{"title":"rotateTowards​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#rotateTowards","content":"Method Pure &lt;/&gt; Quaternion.rotateTowards( from: Quaternion,-- The starting quaternion. to: Quaternion,-- The target quaternion. maxRadiansDelta: number-- The maximum angle in radians to rotate. ) → Quaternion-- The resulting quaternion after rotation. Rotates one quaternion towards another by a maximum angle in radians.  ","version":null,"tagName":"h3"},{"title":"fromEulerAngles​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#fromEulerAngles","content":"Constructor &lt;/&gt; Quaternion.fromEulerAngles( x: number,-- The rotation around the x-axis in radians (pitch). y: number,-- The rotation around the y-axis in radians (yaw). z: number-- The rotation around the z-axis in radians (roll). ) → Quaternion-- The resulting quaternion. Creates a quaternion from Euler angles XYZ in radians.  ","version":null,"tagName":"h3"},{"title":"setCFrame​","type":1,"pageTitle":"Quaternion","url":"/Quaternion-RBLX/api/Quaternion#setCFrame","content":"Method Mutating &lt;/&gt; Quaternion.setCFrame( q: Quaternion,-- The quaternion to set to the CFrame's rotation. cf: CFrame -- The CFrame to convert. ) → Quaternion-- q Creates a quaternion from a CFrame's rotation. ","version":null,"tagName":"h3"}],"options":{"id":"default"}}