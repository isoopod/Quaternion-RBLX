"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[722],{60:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"usage","title":"Quickstart","description":"This page gives a quick\u2011start overview of how to use Quaternion\u2011RBLX in your Roblox projects \u2014 when it\'s useful and how to integrate it with CFrames.","source":"@site/docs/usage.md","sourceDirName":".","slug":"/usage","permalink":"/Quaternion-RBLX/docs/usage","draft":false,"unlisted":false,"editUrl":"https://github.com/isoopod/Quaternion-RBLX/edit/main/docs/usage.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Installation","permalink":"/Quaternion-RBLX/docs/installation"},"next":{"title":"Advanced","permalink":"/Quaternion-RBLX/docs/advanced"}}');var o=t(4848),a=t(8453);const r={sidebar_position:3},s="Quickstart",l={},c=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Common Quaternion Functions",id:"common-quaternion-functions",level:2},{value:"When to use",id:"when-to-use",level:2},{value:"Smooth Interpolation &amp; Animation Transitions",id:"smooth-interpolation--animation-transitions",level:3},{value:"Clean Composition of Multiple Rotations",id:"clean-composition-of-multiple-rotations",level:3},{value:"Avoiding Numerical Instability &amp; Gimbal\u2011Lock Issues",id:"avoiding-numerical-instability--gimballock-issues",level:3},{value:"Efficiency &amp; Clean Code for Rotation\u2011Heavy Systems",id:"efficiency--clean-code-for-rotationheavy-systems",level:3},{value:"Interoperability with Roblox\u2019s CFrame System",id:"interoperability-with-robloxs-cframe-system",level:3},{value:"Example Use Cases",id:"example-use-cases",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"quickstart",children:"Quickstart"})}),"\n",(0,o.jsx)(n.p,{children:"This page gives a quick\u2011start overview of how to use Quaternion\u2011RBLX in your Roblox projects \u2014 when it's useful and how to integrate it with CFrames."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"local Quaternion = require(path.to.Quaternion)\n\n-- Create a quaternion rotation from a CFrame\nlocal cframeRotation = Quaternion.fromCFrame(workspace.CurrentCamera.CFrame)\n\n-- Create a quaternion rotation from Euler Angles\nlocal eulerRotation = Quaternion.fromEulerAngles(0, math.rad(45), 0)\n\n-- Combine the rotations\nlocal combinedRotation = Quaternion.multiply(eulerRotation, cframeRotation)\n\n-- Set the camera to the new rotation\nQuaternion.applyRotation(workspace.CurrentCamera, combinedRotation)\n"})}),"\n",(0,o.jsx)(n.p,{children:"This short example shows you can use Quaternions to rotate the camera by 45 degrees on the yaw axis."}),"\n",(0,o.jsx)(n.p,{children:"It should be noted here that quaternion multiplication is not commutative; the order of multiplication matters."}),"\n",(0,o.jsxs)(n.p,{children:["When you multiply two quaternions, you are applying one rotation after another.",(0,o.jsx)(n.br,{}),"\n","The right-hand side quaternion (",(0,o.jsx)(n.code,{children:"rhs"}),") is applied first, and the left-hand side quaternion (",(0,o.jsx)(n.code,{children:"lhs"}),") is applied ",(0,o.jsx)(n.strong,{children:"after that"}),".",(0,o.jsx)(n.br,{}),"\n","In other words, ",(0,o.jsx)(n.code,{children:"lhs * rhs"})," is taking ",(0,o.jsx)(n.code,{children:"rhs"})," and rotating it by ",(0,o.jsx)(n.code,{children:"lhs"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["This is the same as ",(0,o.jsx)(n.code,{children:"CFrameA"})," * ",(0,o.jsx)(n.code,{children:"CFrameB"}),"; B is applied first and then transformed by A."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"common-quaternion-functions",children:"Common Quaternion Functions"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Operation"}),(0,o.jsx)(n.th,{children:"Method / Use"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"From Euler angles"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.fromEulerAngles(x, y, z)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"From axis + angle"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.fromAxisAngle(axisVec, angleRadians)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"From a CFrame"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.fromCFrame(someCFrame)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Multiply / combine rotations"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.multiply(q1, q2)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Interpolate between orientations"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Quaternion.slerp(q1, q2, t)"})," - useful for smooth transitions"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Convert quaternion \u2192 CFrame"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Quaternion.toCFrame(x, y, z, q)"})," or ",(0,o.jsx)(n.code,{children:"Quaternion.toCFrameAtPosition(posVec, q)"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Apply a rotation to a part"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.applyRotation(partOrModel, q)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Invert quaternion"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.inverse(q)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Get the identity quaternion"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.identity()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Get the angle between quaternions"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.angle(q1, q2)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Look at / look along vectors"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Quaternion.lookAt(pos1, pos2)"})," or ",(0,o.jsx)(n.code,{children:"Quaternion.lookAlong(forward, up)"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Quaternion between two directions"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Quaternion.fromToRotation(dir1, dir2)"})})]})]})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use",children:"When to use"}),"\n",(0,o.jsx)(n.h3,{id:"smooth-interpolation--animation-transitions",children:"Smooth Interpolation & Animation Transitions"}),"\n",(0,o.jsx)(n.p,{children:"If you want to interpolate between two orientations (e.g. camera turning, character aiming, UI rotations), using quaternions + slerp gives smooth, stable transitions. Doing the same via repeated CFrame.Angles or direct matrix\u2011blending often looks janky or results in interpolation artifacts."}),"\n",(0,o.jsx)(n.h3,{id:"clean-composition-of-multiple-rotations",children:"Clean Composition of Multiple Rotations"}),"\n",(0,o.jsx)(n.p,{children:"For complex rotations \u2014 like rotating an object around multiple axes over time, or applying sequential rotations relative to different frames \u2014 quaternions let you compose rotations reliably by quaternion multiplication. This avoids issues that arise when chaining CFrame multiplications and manual angle bookkeeping."}),"\n",(0,o.jsx)(n.h3,{id:"avoiding-numerical-instability--gimballock-issues",children:"Avoiding Numerical Instability & Gimbal\u2011Lock Issues"}),"\n",(0,o.jsx)(n.p,{children:"When using Euler angles (or incremental angle updates), you risk gimbal lock or edge\u2011case singularities depending on axis\u2011order. Quaternions sidestep this entirely. Also, quaternion mathematics tends to remain more numerically stable when combining many rotations."}),"\n",(0,o.jsx)(n.h3,{id:"efficiency--clean-code-for-rotationheavy-systems",children:"Efficiency & Clean Code for Rotation\u2011Heavy Systems"}),"\n",(0,o.jsx)(n.p,{children:"For any system where rotation is a first\u2011class concern (camera rigs, physics\u2011based movement, orientation tweening, spaceship attitude control, procedural motion, etc.), using a quaternion library simplifies code and reduces complexity: rotations become composable, invertible, and easy to manipulate."}),"\n",(0,o.jsx)(n.h3,{id:"interoperability-with-robloxs-cframe-system",children:"Interoperability with Roblox\u2019s CFrame System"}),"\n",(0,o.jsxs)(n.p,{children:["Because Quaternion\u2011RBLX lets you create a quaternion from a CFrame and convert back with ",":ToCFrame","(), you can use it as a drop\u2011in enhancement in existing codebases \u2014 mixing quaternion logic where needed, and falling back to CFrame where convenient."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"Use plain CFrame when you only need simple transforms: positioning, or static orientation, or when you compose transforms in a trivial way and don\u2019t need interpolation or complex rotations."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"example-use-cases",children:"Example Use Cases"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Example: Smoothly rotating a part toward a target orientation\nlocal startQ = Quaternion.fromCFrame(part.CFrame)\nlocal targetQ = Quaternion.fromEulerAngles(0, math.rad(180), 0)  -- face backwards\nlocal t = 0\n\ngame:GetService("RunService").Heartbeat:Connect(function(dt)\n    t = math.min(t + dt, 1)\n    local qInterp = Quaternion.slerp(startQ, targetQ, t)\n    Quaternion.applyRotation(part, qInterp)\nend)\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"-- Example: Combining rotations - e.g. yaw then pitch\nlocal yaw   = Quaternion.fromAxisAngle(Vector3.new(0, 1, 0), math.rad(45))\nlocal pitch = Quaternion.fromAxisAngle(Vector3.new(1, 0, 0), math.rad(30))\nlocal final = Quaternion.multiply(yaw, pitch)\n\nQuaternion.applyRotation(part, final)\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"-- Example: Look\u2011direction orientation (e.g. camera / turret / head)\nQuaternion.applyRotation(part, Quaternion.lookAt(part.Position, targetPosition))\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Quaternion\u2011RBLX gives you a robust, expressive, and stable way to handle rotations. It plays nicely with Roblox\u2019s native CFrame system, yet unlocks more advanced rotation\u2011centric logic: smooth interpolation, complex composition, orientation blending, look\u2011at logic, and more."}),"\n",(0,o.jsx)(n.p,{children:"If your game or simulation involves anything more than \u201cset this part to a fixed rotation\u201d \u2014 especially dynamic or continuous rotations \u2014 quaternions are absolutely worth using."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);