"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[976],{7879:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"intro","title":"Intro","description":"Quaternion RBLX is a Roblox library which provides a robust library for using quaternions for rotations.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/Quaternion-RBLX/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/isoopod/Quaternion-RBLX/edit/main/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","next":{"title":"Installation","permalink":"/Quaternion-RBLX/docs/installation"}}');var r=i(4848),t=i(8453);const a={sidebar_position:1},s="Intro",l={},c=[{value:"What is a Quaternion?",id:"what-is-a-quaternion",level:2},{value:"How Quaternions Differ to CFrames?",id:"how-quaternions-differ-to-cframes",level:3},{value:"Why Use Quaternions?",id:"why-use-quaternions",level:2},{value:"1. Avoid Gimbal Lock",id:"1-avoid-gimbal-lock",level:3},{value:"2. Smooth Interpolation",id:"2-smooth-interpolation",level:3},{value:"3. Compact and Efficient",id:"3-compact-and-efficient",level:3},{value:"4. Stable Composition",id:"4-stable-composition",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"intro",children:"Intro"})}),"\n",(0,r.jsx)(n.p,{children:"Quaternion RBLX is a Roblox library which provides a robust library for using quaternions for rotations."}),"\n",(0,r.jsx)(n.h2,{id:"what-is-a-quaternion",children:"What is a Quaternion?"}),"\n",(0,r.jsxs)(n.p,{children:["A quaternion is a mathematical object that can represent a rotation in 3D space using four numbers ",(0,r.jsx)(n.code,{children:"(x, y, z, w)"}),". Unlike Euler angles or ",(0,r.jsx)(n.code,{children:"CFrame.Angles"}),", quaternions do not suffer from glimbal lock and can be smoothly interpolated."]}),"\n",(0,r.jsx)(n.p,{children:"Key points:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["They represent rotation ",(0,r.jsx)(n.em,{children:"independently"})," of position."]}),"\n",(0,r.jsxs)(n.li,{children:["They can be ",(0,r.jsx)(n.em,{children:"combined efficiently"})," through multiplication."]}),"\n",(0,r.jsxs)(n.li,{children:["They allow for ",(0,r.jsx)(n.em,{children:"smooth interpolation"})," between rotations (slerp)."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"how-quaternions-differ-to-cframes",children:"How Quaternions Differ to CFrames?"}),"\n",(0,r.jsxs)(n.p,{children:["A CFrame is a ",(0,r.jsx)(n.em,{children:"4x4 Affine Transformation Matrix"}),". We however only think about CFrames as a 4x3 matrix, or a 3x3 rotation matrix and Vector3 position. This is because Roblox abstracted away the last row of the 4x4 matrix, which is always [0, 0, 0, 1]. Affine Transformation Matrices are industry standard for 3D engines, but most engines have you work with rotations using quaternions instead of on the matrix directly. The reason:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Stability:"})," Repeated matrix multiplications can introduce numerical errors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Interpolation:"})," Smooth rotation blending is easier with quaternions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Efficiency:"})," Quaternions are easier to multiply than rotation matrices, and smaller in memory. Most game engines will store rotations as quaternions internally because of this, only converting to an affine transformation matrix for rendering or other areas where it performs better."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In Roblox, ",(0,r.jsx)(n.code,{children:"CFrame"})," exposes this matrix directly, but working with quaternions allows you to benefit from these advantages while still converting to/from CFrames when needed."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"why-use-quaternions",children:"Why Use Quaternions?"}),"\n",(0,r.jsxs)(n.p,{children:["Even though Roblox provides many methods in ",(0,r.jsx)(n.code,{children:"CFrame"})," for rotations, quaternions offer several important benefits:"]}),"\n",(0,r.jsx)(n.h3,{id:"1-avoid-gimbal-lock",children:"1. Avoid Gimbal Lock"}),"\n",(0,r.jsxs)(n.p,{children:["Euler angles (",(0,r.jsx)(n.code,{children:"Vector3"}),") or incremental ",(0,r.jsx)(n.code,{children:"CFrame.Angles"})," can suffer from ",(0,r.jsx)(n.strong,{children:"gimbal lock"}),", a situation where two rotation axes align and you lose a degree of freedom. Quaternions represent rotations in 4D space, eliminating gimbal lock entirely."]}),"\n",(0,r.jsx)(n.h3,{id:"2-smooth-interpolation",children:"2. Smooth Interpolation"}),"\n",(0,r.jsxs)(n.p,{children:["Rotations between two orientations can be smoothly interpolated using ",(0,r.jsx)(n.strong,{children:"slerp"})," (spherical linear interpolation), which is trivial with quaternions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local q1 = Quaternion.fromCFrame(CFrame.Angles(0, 0, 0))\nlocal q2 = Quaternion.fromCFrame(CFrame.Angles(0, math.rad(90), 0))\nlocal qInterpolated = Quaternion.slerp(q1, q2, 0.5)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This produces a natural, consistent rotation, which is much harder to achieve with CFrames directly."}),"\n",(0,r.jsx)(n.h3,{id:"3-compact-and-efficient",children:"3. Compact and Efficient"}),"\n",(0,r.jsxs)(n.p,{children:["Quaternions store rotations using only four numbers ",(0,r.jsx)(n.code,{children:"(x, y, z, w)"}),", instead of a full 3x3 matrix. They are easy to combine using multiplication, and more memory-efficient than repeatedly constructing ",(0,r.jsx)(n.code,{children:"CFrame"})," matrices."]}),"\n",(0,r.jsx)(n.h3,{id:"4-stable-composition",children:"4. Stable Composition"}),"\n",(0,r.jsx)(n.p,{children:"Combining multiple rotations is cleaner with quaternions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local q1 = Quaternion.fromEulerAngles(0, math.rad(45), 0)\nlocal q2 = Quaternion.fromEulerAngles(math.rad(30), 0, 0)\nlocal qCombined = Quaternion.multiply(q1, q2)\nlocal cframe = Quaternion.rotation(qCombined)\n"})}),"\n",(0,r.jsx)(n.p,{children:"With CFrames, repeated multiplication can introduce numerical drift, whereas quaternions remain stable and normalised."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Quaternions give you a ",(0,r.jsx)(n.em,{children:"robust, stable, and mathematically sound"})," way to handle rotations in Roblox, making your animations, physics, and camera systems far more predictable and smooth than using ",(0,r.jsx)(n.code,{children:"CFrame"})," angles alone."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var o=i(6540);const r={},t=o.createContext(r);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);