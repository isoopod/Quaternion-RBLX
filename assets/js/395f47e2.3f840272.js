"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[912],{9469:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"advanced","title":"Advanced","description":"This guide covers more advanced use cases \u2014 and importantly, highlights performance-sensitive operations, how to use the \u201cpure\u201d vs \u201cin-place / mutating\u201d variants, and when that distinction matters.","source":"@site/docs/advanced.md","sourceDirName":".","slug":"/advanced","permalink":"/Quaternion-RBLX/docs/advanced","draft":false,"unlisted":false,"editUrl":"https://github.com/isoopod/Quaternion-RBLX/edit/main/docs/advanced.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"defaultSidebar","previous":{"title":"Quickstart","permalink":"/Quaternion-RBLX/docs/usage"}}');var o=t(4848),a=t(8453);const i={sidebar_position:4},s="Advanced",c={},l=[{value:"API Overview (key features)",id:"api-overview-key-features",level:2},{value:"Performance Considerations &amp; \u201cPure\u201d vs \u201cIn-Place / Mutating\u201d Variants",id:"performance-considerations--pure-vs-in-place--mutating-variants",level:2},{value:"When to use pure (functional) methods",id:"when-to-use-pure-functional-methods",level:3},{value:"When to prefer in-place (mutating) methods",id:"when-to-prefer-in-place-mutating-methods",level:3},{value:"Vector Rotations &amp; Directional Transformations",id:"vector-rotations--directional-transformations",level:2},{value:"Rotation-Delta, Angular Velocity &amp; Physics-Style Continuous Rotation",id:"rotation-delta-angular-velocity--physics-style-continuous-rotation",level:2},{value:"Advanced Example",id:"advanced-example",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"advanced",children:"Advanced"})}),"\n",(0,o.jsx)(n.p,{children:"This guide covers more advanced use cases \u2014 and importantly, highlights performance-sensitive operations, how to use the \u201cpure\u201d vs \u201cin-place / mutating\u201d variants, and when that distinction matters."}),"\n",(0,o.jsx)(n.h2,{id:"api-overview-key-features",children:"API Overview (key features)"}),"\n",(0,o.jsx)(n.p,{children:"Quaternion-RBLX provides a comprehensive set of quaternion operations, including:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Constructors:"})," ",(0,o.jsx)(n.code,{children:".new(x, y, z, w)"}),", ",(0,o.jsx)(n.code,{children:".fromEulerAngles(...)"}),", ",(0,o.jsx)(n.code,{children:".fromAxisAngle(axis, angle)"}),", ",(0,o.jsx)(n.code,{children:".fromCFrame(...)"}),", ",(0,o.jsx)(n.code,{children:".lookAt(...)"}),", ",(0,o.jsx)(n.code,{children:".lookAlong(...)"}),", ",(0,o.jsx)(n.code,{children:".fromToRotation(...)"}),", etc."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Decomposition:"})," ",(0,o.jsx)(n.code,{children:".getComponents()"}),", ",(0,o.jsx)(n.code,{children:".toEulerAngles()"}),", ",(0,o.jsx)(n.code,{children:".toAxisAngle()"}),", ",(0,o.jsx)(n.code,{children:".toCFrame(position)"}),", etc."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Quaternion math:"})," ",(0,o.jsx)(n.code,{children:".multiply(...)"}),", ",(0,o.jsx)(n.code,{children:".inverse()"}),", ",(0,o.jsx)(n.code,{children:".normalize()"}),", ",(0,o.jsx)(n.code,{children:".dot(...)"}),", ",(0,o.jsx)(n.code,{children:".angle(...)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Rotation of vectors:"})," ",(0,o.jsx)(n.code,{children:".rotateVector(...)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interpolation:"})," ",(0,o.jsx)(n.code,{children:".slerp(...)"}),", ",(0,o.jsx)(n.code,{children:".nlerp(...)"}),", ",(0,o.jsx)(n.code,{children:".rotateTowards(...)"}),", and in-place variants (e.g. ",(0,o.jsx)(n.code,{children:".slerpInPlace(...)"}),", ",(0,o.jsx)(n.code,{children:".rotateTowardsInPlace(...)"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Utility:"})," ",(0,o.jsx)(n.code,{children:".magnitude()"}),", ",(0,o.jsx)(n.code,{children:".magnitudeSquared()"}),", ",(0,o.jsx)(n.code,{children:".equals()"}),", ",(0,o.jsx)(n.code,{children:".fuzzyEquals(...)"}),", ",(0,o.jsx)(n.code,{children:".tostring(...)"}),", property-style getters (",(0,o.jsx)(n.code,{children:".x"}),", ",(0,o.jsx)(n.code,{children:".y"}),", ",(0,o.jsx)(n.code,{children:".z"}),", ",(0,o.jsx)(n.code,{children:".w"}),") etc."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"performance-considerations--pure-vs-in-place--mutating-variants",children:"Performance Considerations & \u201cPure\u201d vs \u201cIn-Place / Mutating\u201d Variants"}),"\n",(0,o.jsx)(n.p,{children:"Because Quaternion-RBLX uses a fixed buffer type under the hood, it provides both pure (functional) and in-place (mutating) variants of many operations."}),"\n",(0,o.jsx)(n.h3,{id:"when-to-use-pure-functional-methods",children:"When to use pure (functional) methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"When you need immutability (keeping old orientations, branching rotations, preserving original quaternion state)"}),"\n",(0,o.jsx)(n.li,{children:"When readability / clarity is more important than micro-optimisation \u2014 e.g. setup code, configuration, one-off rotations"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"local q1 = Quaternion.fromEulerAngles(0, math.rad(45), 0)\nlocal q2 = Quaternion.fromAxisAngle(Vector3.new(1,0,0), math.rad(30))\nlocal qCombined = Quaternion.multiply(q1, q2)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Here both q1 and q2 remain unchanged; qCombined is new."}),"\n",(0,o.jsx)(n.h3,{id:"when-to-prefer-in-place-mutating-methods",children:"When to prefer in-place (mutating) methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"In performance-critical loops (e.g. per-frame updates, animations, physics loops)"}),"\n",(0,o.jsx)(n.li,{children:"When you want to minimise memory allocations / garbage / buffer churn"}),"\n",(0,o.jsx)(n.li,{children:"When you are reusing quaternion objects (e.g. continuously rotating an object, or interpolating over time)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"local currentQ = Quaternion.fromCFrame(part.CFrame)\n-- reuse the same quaternion each frame\nQuaternion.slerpInPlace(currentQ, currentQ, targetQ, t)\nQuaternion.applyRotation(part, currentQ)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Or:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"Quaternion.rotateTowardsInPlace(currentQ, currentQ, targetQ, math.rad(5) * dt)\nQuaternion.applyRotation(part, currentQ)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Because the buffer is mutated instead of creating a new quaternion each time, this reduces memory churn and can lead to smoother performance, especially in contexts where many quaternion operations happen per frame (e.g. real-time physics, animations, camera rigs, procedural systems)."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"vector-rotations--directional-transformations",children:"Vector Rotations & Directional Transformations"}),"\n",(0,o.jsx)(n.p,{children:"If you need to rotate direction vectors (like forward/up/right) or compute transformed offsets (e.g. firing direction, velocity vectors, local-space offsets), quaternions let you rotate vectors cleanly:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:"local q = Quaternion.fromAxisAngle(Vector3.new(0,1,0), math.rad(90))\nlocal original = Vector3.new(1, 0, 0)\nlocal rotated = Quaternion.rotateVector(q, original)\n-- rotated is now roughly Vector3.new(0, 0, -1)\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is much cleaner than constructing a full CFrame just to rotate a vector, and avoids unnecessary overhead when you only care about direction \u2014 ideal for projectiles, physics impulses, local offsets, procedural motion, etc."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"rotation-delta-angular-velocity--physics-style-continuous-rotation",children:"Rotation-Delta, Angular Velocity & Physics-Style Continuous Rotation"}),"\n",(0,o.jsx)(n.p,{children:"For continuous rotations \u2014 e.g. rotating an object at a constant angular velocity (wheels, spinning objects, rotating turrets), or applying incremental rotation deltas per frame \u2014 quaternions are excellent. You can convert an angular velocity (axis + angular speed) to a quaternion and multiply it with the current orientation each update:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'local currentQ = Quaternion.fromCFrame(part.CFrame)\nlocal angularAxis = Vector3.new(0, 1, 0)\nlocal angularSpeed = math.rad(90)  -- 90 degrees per second\n\ngame:GetService("RunService").Heartbeat:Connect(function(dt)\n    local deltaQ = Quaternion.fromAxisAngle(angularAxis, angularSpeed * dt)\n    Quaternion.multiplyInPlace(currentQ, deltaQ, currentQ)\n    Quaternion.applyRotation(part, currentQ)\nend)\n'})}),"\n",(0,o.jsx)(n.p,{children:"This maintains smooth, stable rotation over time without accumulating drift, and works cleanly even with changing frame rates."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"advanced-example",children:"Advanced Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'local part = workspace.Turret\nlocal currentQ = Quaternion.fromCFrame(part.CFrame)\nlocal targetPos = workspace.Target.Position\nlocal rotationSpeed = math.rad(30)  -- spin speed (radians per second)\n\ngame:GetService("RunService").Heartbeat:Connect(function(dt)\n    -- 1. Compute look-at quaternion\n    local lookQ = Quaternion.lookAt(part.Position, targetPos)\n\n    -- 2. Rotate current orientation toward lookQ (limited angular speed)\n    Quaternion.rotateTowardsInPlace(currentQ, currentQ, lookQ, rotationSpeed * dt)\n\n    -- 3. Apply a slow continuous spin around Z (e.g. turret barrel)\n    local spinQ = Quaternion.fromAxisAngle(Vector3.ZAxis, rotationSpeed * dt)\n    Quaternion.multiplyInPlace(currentQ, spinQ, currentQ)\n\n    Quaternion.applyRotation(part, currentQ)\nend)\n'})}),"\n",(0,o.jsx)(n.p,{children:"This snippet shows how you can mix interpolation, look-at orientation, and continuous rotation \u2014 all cleanly handled via quaternions, with minimal allocations if used with in-place / reused quaternion buffers."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(6540);const o={},a=r.createContext(o);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);